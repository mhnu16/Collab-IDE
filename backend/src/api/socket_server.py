import json
import flask
import flask_socketio as fsock

from utils import SERVER
from database import Database, Project, Session, User

class SocketServer:
    def __init__(self, app: flask.Flask):
        self.app = app
        self.database = Database.get_instance()
        self.socketio = fsock.SocketIO(self.app, cors_allowed_origins="*", logger=True)

        @self.socketio.on("connect")
        def on_connect():
            print(f"{"-":>10} Client connected")
            project_id = flask.request.cookies.get("project_id")
            if not project_id:
                print("No project ID Provided")
                self.emit("connect_error", False, {"error": "No project ID Provided"})
                return
            session_id = flask.request.cookies.get("session_id")
            if not session_id:
                print("No session ID Provided")
                self.emit("connect_error", False, {"error": "No session ID Provided"})
                return
            with self.database.session_scope():
                session = self.database.select_from(Session, Session.session_id == session_id)
                if not session:
                    print("Invalid session ID")
                    self.emit("connect_error", False, {"error": "Invalid session ID"})
                    return
                user = self.database.select_from(User, User.id == session.user_id)
                if not user:
                    print("Invalid user ID")
                    self.emit("connect_error", False, {"error": "Invalid user ID"})
                    return
                projects_ids = [project.project_id for project in user.projects]
                if project_id not in projects_ids:
                    print("User does not have access to project")
                    self.emit("connect_error", False, {"error": "User does not have access to project"})
                    return
                fsock.join_room(project_id)
                print(f"{"-":>10} Client connected to project {project_id}")

        @self.socketio.on("disconnect")
        def on_disconnect():
            print(f"{"-":>10} {flask.request.sid} disconnected")
            project_id = flask.request.cookies.get("project_id")
            if project_id:
                print(f"{"-":>10} Leaving project/room {project_id}")
                fsock.leave_room(project_id)


        @self.socketio.on("get_file")
        def on_get_file(json_str: str):
            data = json.loads(json_str)
            filename = data.get("filename")
            project_id = flask.request.cookies.get("project_id")
            if project_id and filename:
                file = self.database.get_file(project_id, filename)
                if file:
                    self.emit("get_file", True, {"file": file})
                else:
                    self.emit("get_file", False, {"error": "File not found"})
            else:
                self.emit("get_file", False, {"error": "Invalid request"})

        @self.socketio.on("create_file")
        def on_create_file(json_str: str):
            data = json.loads(json_str)
            filename = data.get("filename")
            project_id = flask.request.cookies.get("project_id")
            if project_id and filename:
                file = self.database.create_file(project_id, filename)
                with self.database.session_scope():
                    project = self.database.select_from(Project, Project.project_id == project_id)
                    if project:
                        structure = project.get_structure()
                        if file:
                            self.emit("create_file", True, {})
                            self.emit("structure_update", True, {"structure": structure}, to=project_id)
                        else:
                            self.emit("create_file", False, {"error": "Failed to create file"})
            else:
                self.emit("create_file", False, {"error": "Invalid request"})

        @self.socketio.on("file_content_update")
        def on_file_content_update(json_str: str):
            data = json.loads(json_str)
            filename = data.get("filename")
            changes = data.get("changes") # A list of changes generated by the monaco editor
            project_id = flask.request.cookies.get("project_id")
            if project_id and filename and changes:
                success = self.database.apply_changes(project_id, filename, changes)
                if success:
                    print(f"{"-":>10} File content updated for {filename}")
                    self.emit("file_content_updated", True, {"changes": changes, "filename": filename}, to=project_id, include_self=False)
                    self.emit("file_content_update", True, {}, to=flask.request.sid)
                else:
                    print(f"{"-":>10} Failed to apply changes for {filename}")
                    self.emit("file_content_update", False, {"error": "Failed to apply changes"})
            else:
                self.emit("file_content_update", False, {"error": "Invalid request"})

        @self.socketio.on("file_hash_request")
        def on_file_hash_request(json_str: str):
            data = json.loads(json_str)
            filename = data.get("filename")
            project_id = flask.request.cookies.get("project_id")
            if project_id and filename:
                file_hash = self.database.get_file_hash(project_id, filename)
                if file_hash:
                    self.emit("file_hash_request", True, {"hash": file_hash})
                else:
                    self.emit("file_hash_request", False, {"error": "File not found"})
            else:
                self.emit("file_hash_request", False, {"error": "Invalid request"})

    def emit(self, event: str, success: bool, data: dict, to: str | None = None, **kwargs):
        """
        Emit an event to a specific room or client

        :param event: The event to emit
        :param success: Whether the request was successful
        :param data: The data to send
        :param to: The room or client to send the data to (default is to only the client that sent the request)
        :param kwargs: Additional arguments to pass to the emit
        """
        if to is None:
            to = flask.request.sid

        self.socketio.emit(event, {"success": success, "data": data}, to=to, **kwargs)

    def start(self, debug=False):
        self.socketio.run(
            self.app,
            host=SERVER.IP,
            port=SERVER.PORT,
            debug=debug,
            use_reloader=debug,
            log_output=debug,
        )
